[!
	use TUSK::Import;
	use TUSK::Import::Structure;
	use HSDB4::Constants;
	use TUSK::Constants;
	use HSDB45::UserGroup;
!][-
	$req = shift;
	$req->{include_dir} = $req_rec->server_root_relative($ENV{EMBPERL_LIB});
	
	$req->{checkforadmin} = 1;
	$req->{mustbeadmin} = 1;

	$req->{pagetype}="";
	$req->{image}="ImportStudents";
	
	Execute($req->{include_dir}."/manage/master");
	Execute({inputfile=>$req->{include_dir}."/prepend.html",import=>1});

	manage_header($req);
	$fail = 0;
	if ($fdat{datafile}) {
		$import = TUSK::Import->new;
		$import->add_log("summary","test run, course links will not be created") unless ($fdat{save});
		$struct = TUSK::Import::Structure->new;
		## this set of conditionals is to account for different kinds of files, from different schools
		if ($fdat{preset_fields} eq "sisfeed") {
			@file_fields = qw(sid user_id lastname firstname midname email trunk);
		}
		elsif ($fdat{preset_fields} eq "medfeed") {
			@file_fields = qw(classyear gradyear sid lastname firstname user_id);
		}
		else {
			@file_fields = split(/\s*,\s*/,$fdat{fields});
		}
		$import->set_fields(@file_fields);
		$import->read_filehandle($fdat{datafile},"\t");

		@errMsgs = @{$import->get_err_msgs};
		if (!@errMsgs){
			if ($fdat{limit_field} && $fdat{limit_value}) {
				$import->grep_records($fdat{limit_field},$fdat{limit_value});
				$import->add_log("summary","limiting records to where $fdat{limit_field} = $fdat{limit_value}");
			}
			$import->add_log("summary","processing ".scalar $import->get_records." records");
			if ($fdat{save} && $fdat{clean_group}) {
				$ug = HSDB45::UserGroup->new(_id => $fdat{user_group_id}, _school => $req->{school});
				$ug->delete_children($TUSK::Constants::DatabaseUsers->{ContentManager}->{readusername}, $TUSK::Constants::DatabaseUsers->{ContentManager}->{readpassword});
				$import->add_log("summary","removed existing users from ".$ug->out_label);
			}


			foreach $r ($import->get_records) {
				$user_id = $r->get_field_value("user_id");
				$import->add_log("record","looking up user_id: $user_id");
				$user = HSDB4::SQLRow::User->new->lookup_key($user_id);

				if ($user->primary_key) {
					$import->add_log("warn", "$user_id exists - will update account");
				}

				if ($fdat{save}) {
					if (!$user->primary_key) {
						$user->primary_key($user_id);
						$user_msg = "created account for $user_id";
					}
					else {
						$user_msg = "updated account for $user_id";
					}

					foreach $field (@file_fields) {
						next if $field =~ /^user_id$/;
						next unless grep { $field =~ /$_/ } $user->fields;
						$user->field_value($field,$r->get_field_value($field));
					}	

					## determine what affiliation to give the user
					if (grep { $_ =~ /affiliation/ } @file_fields) {
						$user->field_value("affiliation",$r->get_field_value("affiliation"));
						$user_msg .= " (affiliation ".$user->field_value("affiliation").")";
					}
					else {
						$user->field_value("affiliation",$req->{school});
						$user_msg .= " (affiliation ".$user->field_value("affiliation").")";						
					}
					$user->save($TUSK::Constants::DatabaseUsers->{ContentManager}->{readusername}, $TUSK::Constants::DatabaseUsers->{ContentManager}->{readpassword});
					$import->add_log("record",$user_msg);

					if($fdat{reset_password}){
						$user->admin_reset_password();
					}

					if ($fdat{user_group_id}) {
						$ug = HSDB45::UserGroup->new(_id => $fdat{user_group_id}, _school => $req->{school});
						if ($ug->contains_user($user_id)) {
							$import->add_log("warn", "$user_id already in ".$ug->out_label." user group");	
						} else {
							$ug->add_user($user,$TUSK::Constants::DatabaseUsers->{ContentManager}->{readusername}, $TUSK::Constants::DatabaseUsers->{ContentManager}->{readpassword});
							$import->add_log("record", "$user_id added to ".$ug->out_label." user group");	
						}
					}									 

				}
			}
			$import->add_log("summary","$fail failed records");
			@logs = $import->get_logs;
		} # end of error msg state
	}
-]
<form name="data_form" action="" method="post" enctype="multipart/form-data" onsubmit="return checkform(this);" class="no-padding">
<table cellpadding="0">
<tr>
<td class="labelgray">Import type:</td><td class="cell-left"><table class="tusk" width="50%"><tr><td>Test<input type="radio" name="save" value="0" checked></td><td align="right">Live<input type="radio" name="save" value="1"></td></tr></table><br>"Test" verifies data, but does not save. "Live" verifies and saves data.</td>
</tr>
[$ if ($req->{school}) $]
<input type="hidden" name="school" value="[+ $req->{school} +]">
<tr><td class="labelgray">School: </td><td class="cell-left">[+ $req->{school} +]</td></tr>
[$ else $]
<tr><td class="labelgray">School: </td><td class="cell-left">school not provided</div></td></tr>
[$ endif $]

<tr>
<td class="labelgray">Fields in File:</td>
<td class="cell-left">
<input type="radio" name="preset_fields" value="sisfeed" checked="checked"> SIS file (sid,user_id,lastname,firstname,midname,email,trunk)<br>
[$ if $req->{school} eq "Medical" $]
<input type="radio" name="preset_fields" value="medfeed"> Med file (classyear,gradyear,sid,lastname,firstname,user_id)<br>
[$ endif $]
<br>
<input type="radio" name="preset_fields" value="self"> <input name="fields" value="[+ $fdat{fields}+]" size="50" class="textareawhite"><br>
<div> Either select a standard import format, or list the fields in the import file, separated by commas. Fields that align with column names in the TUSK user table will be saved along with the user.</div><br/>
<div><b>Please note</b> that fields in any import file must be separated by a <strong>tab</strong>.</div>
</td>
</tr>

<tr>
<td class="labelgray">Limit Results:</td>
<td class="cell-left">
Field: <input name="limit_field" value="[+ $fdat{limit_field} +]" size="20" class="textareawhite"> &nbsp;&nbsp;Value: <input name="limit_value" value="[+ $fdat{limit_value} +]" size="20" class="textareawhite"><br>
<div> If you would like to selectively import only certain students from your import file, you may use these field to use only
records that match a certain criteria.  Just input the name of a field to look at and a value to search for, and any record that meets 
your criteria will be imported.  For example, the field could be &quot;lastname&quot; and the value could be &quot;Jones&quot;, this 
combination would only import students who have Jones as their last name.</div>
</td>
</tr>

<tr>
<td class="labelgray">File:</td><td class="cell-left"><input type="file" name="datafile" class="formbutton" id="File__y"></td>
</tr>

<tr>
<td class="labelgray">User Group:</td>
<td class="cell-left">
<select name="user_group_id">
<option value="0">none</option>
[$ foreach $group (HSDB45::UserGroup->new(_school => $req->{school})->lookup_conditions("sub_group='No'","order by label")) $]
<option value="[+ $group->primary_key +]"[+ $fdat{user_group_id} == $group->primary_key ? " SELECTED" : ""+]>[+ $group->out_label +] ([+ $group->primary_key +])</option>
[$ endforeach $]
</select><br>
Choose user group to add all users (optional)
<br><br>
<input type="checkbox" name="clean_group"> Remove existing users from group before adding new users.

</td>
</tr>
<tr>
	<td class="labelgray">Email Password:</td>
	<td class="cell-left"><input name="reset_password" type="checkbox">Create/Reset and Email Password to User</td>
</tr>
<tr>
<td>&nbsp;</td><td class="cell-submit"><input type="submit" value="Process" class="formbutton"></td>
</tr>
</table>
</form>
[- $i = 1 -]
[$ foreach $log (@logs) $]
	[$ if ($log->get_type =~ /(error)/) $]
		<div class="[+ $log->get_type +]">[+ $log->get_type +] [+ $i +]: [+ $log->get_message +]</div>
	[- $i ++ -]
	[$ endif $]
[$ endforeach $]
[$ if (@logs) $]
<h4>Log Messages</h4>
[$ foreach $log (@logs) $]
	<div class="[+ $log->get_type +]">[+ $log->get_message +]</div>
[$ endforeach $]
[$ endif $]
[$ if (@errMsgs) $]
<h4> Import Errors </h4>
[$ foreach $msg (@errMsgs) $]
	<p class="importError">[+ $msg +]</p>
[$ endforeach $]
[$ endif $]

[- manage_footer(); -]
