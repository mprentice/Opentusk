<html>
<body>

<div align="center"><h1>Perl Style</h1></div>

<h2>1. General Principles</h2>

<h3>1.1. Adhere to the style of the original</h3>

<p>
Do not make gratuitous stylistic changes to existing code that could
break its functionality unless you have a comprehensive testing suite
that instills a high degree of confidence that the code works as it should.
</p>

<h3>1.2. Adhere to the Principle of Least Astonishment</h3>

<p>
Our software should not surprise our users, or at the very least, it
should only surprise our really dumb users who will be astonished at
any software behavior regardless of how good it is.
</p>

<h4>1.2.1. Simplicity</h4>

<p>
Classes should be as simple as possible, and no simpler.  If a class
seems too complex, it should be broken up into one or more classes.
</p>

<h4>1.2.2. Clarity</h4>

<p>
Software components should have an obvious purpose.  This will come as
a natural corrolary of good design and thoughtful naming.
</p>

<h4>1.2.3. Completeness</h4>

<p>
Within reason, give the user the functionality that they want.  Make
sure that it is well documented.
</p>

<h4>1.2.4. Consistency</h4>

<p>
Unique things should have a unique look and feel, and similar things
should have a similar look and feel.  Appeal to user intuition.
</p>

<h4>1.2.5. Robustness</h4>

<p>
Don't foist buggy software off on unwitting users.  Test functionality
thoroughly and make sure that documentation is correct.
</p>

<h3>1.3. Do it right the first time</h3>

<p>
Don't cut corners just to make a deadline.  You'll only be digging your
hole deeper, making it even less plausible that you'll get out of it
in time for the next deadline.
</p>

<h3>1.4. Document any deviations</h3>

<p>
If you're going to be a rebel, please tell someone so they can slap
you, or at least be cognizant of your deviant behavior and understand
that it is being done for a good reason.
</p>

<h2>2. Formatting Conventions</h2>

<h3>2.1. Indentation</h3>

<p>
Each level of indentation should use four spaces.  Long argument
lists, particularly ones with named parameters should be aligned
vertically.
</p>

<pre>
if ($foo) {
    if ($bar) {
        baz($biz);

	fie('this' => 'that',
	    'some' => 'thing',
	    'what' => 'ever);
    }
}
</pre>

<h3>2.2. Whitespace</h3>

<h4>2.2.1. Function calls</h4>

<p>
Do not put a space between a function name and the opening parenthesis
of its argument list.  Do put a space between a comma and the following
argument.
</p>

<pre>
foo($bar, $baz, $biz);
</pre>

<h4>2.2.2. Conditionals</h4>

<p>
Do put a space between the keyword and the opening parenthesis.  Do
not put whitespace after the opening parenthesis or before the closing
parenthesis. Do put a space between the closing parenthesis and the
curly brace.
</p>

<pre>
if (defined($foo) and some_property($foo)) {
    operate_on($foo);
}
</pre>

<h4>2.2.3. Blocks</h4>

<p>
Put a blank line after a block or cluster of blocks.  Also, cluster
together logically related line of code, and insert a blank line
between such clusters.
</p>

<pre>
if ($foo) {
    meow();
}
else {
    woof();
}

now_for_something($completely_different);
</pre>

<h4>2.2.4. Exceptions</h4>

<p>
Link the exception handling to the block for which it is doing the
handling.
</p>

<pre>
eval {
    step_into($traffic);
    play_with($fire);
    tempt($fate);
};
if ($@) {
    die("$@\t...a gruesome death");
}
</pre>

<h3>2.3. Line breaks</h3>

<h4>2.3.1. Functions and conditionals</h4>

<p>
If function calls or conditionals run long, split them up neatly onto
multiple lines.  For conditionals, place the opening curly brace on a
line of its own.
</p>

<pre>
if (some_horribly_long_expression($foo)  and
    some_other_unwieldy_expression($bar) and
    yet_another_mish_mash_of_stuff($baz))
{
    now_for_fun($foo);
    do_this($bar);
    do_that($baz);
}
</pre>

<h4>2.3.2. Regular expressions</h4>

<p>
Simple regular expressions may go all on one line, but for really
heinous ones, break them up onto multiple lines with the x modifier,
putting in useful comments.
<p>

<pre>
m{
    \b        # start at a word boundary
    (\w\S+)   # find a wordish chunk
    (
        \s+   # separated by some whitespace
	\1    # and that chunk again
    ) +       # repeat ad lib
    \b        # until another word boundary
}x
</pre>

<h3>2.4. Conditional positions</h3>

<p>
If a conditional and its associated block is too long to fit on one
line, then the conditional should be prefix.
</p>

<pre>
unless (foo($bar) and baz($biz) and silly($thing) and something($else)) {
    do_this($bar);
    do_that($baz);
    do_something($else);
}
</pre>

<p>
If it is very short, and it improves readability, place it all on one
line.  A general rule would be that if it reads like a good English
sentence, then that is a good form.  If using prefix positioning for a
one-liner, then omit the semicolon.
</p>

<pre>
die("in obscurity") unless $lucky;

if ($in_trouble) { run_away() }
</pre>

<p>
If the conditional is long, but the block is only a single statement,
the conditional may be placed in the postfix position.
</p>

<h3>2.5. Parentheses</h3>

<p>
Use them in most situations as they will improve clarity, though in
some cases, such as for very short conditionals that just the logical
truth of a variable, they may be omitted.
</p>

<h2>3. Naming Conventions</h2>

All names should be as short as possible, but no shorter.  Names
should be meaningful, so much so that they practically obviate the
need for code comments.  If the purpose of a variable is not clear, it
probably has a lame name.  Furthermore, try to make the names reflect
the domain.

<h3>3.1. Classes and Packages</h3>

<p>
Classes and packages should be named as nouns.  Pluralize classes that
represent collections, e.g. Eval::Results, not Eval::Result.  The
first letter of each word in the name should be capitalized.  There
should be no non-alphanumeric characters in class and package names.
The unit test class for a given class should have the same name except
that it has 'Test' appended to it, i.e. class Foo::Bar would have a
unit test class called Foo::BarTest.
</p>

<h3>3.2. Functions and Methods</h3>

<p>
A function or method should be named as either a verb, an adjective,
or possibly could involve an adverb.  Do not use the word 'do' as part
of a function name as it conveys absolutely no useful information.
Characters in the name can be alphanumerics and underscores.
Underscores should separate each word, and all alphas should be
lowercase.  Methods intended to be private should begin with an
underscore.  Accessor methods should be of the form get_foo and
set_foo as opposed to just having an accessor called foo that is
called with a variable number of arguments.  As a variant, an accessor
that informs the client of a boolean state can be of the form is_foo.
</p>

<p>
Arguments to a function or method should be shifted from @_ into named
variables to clarify what the incoming arguments are.  For method
invocation, the first argument should be shifted into $self, except in
the case of constructors.  "Named parameters" may be accomplished by
using a hash as follows...
</p>

<pre>
$thingy->foo('bar' => 'baz', 'what' => 'ever');

sub foo {
    my $self = shift;
    my %params = @_;
    my $bar = $params{bar};
    my $what = $params{what};
    ...
}
</pre>

<h3>3.3. Variable Names</h3>

<p>
A variable name should typically be a noun, though occasionally may be
either an adjective, or even more rarely an adverb.  Arrays should be
pluralized nouns.  The characters of a variable name should be
alphanumeric, all lowercase, with words separated by underscores.
</p>

<h3>3.4. Constants</h3>

<p>
Constants should be named with alphanumerics, separating words with
underscores, and should be in all caps.
</p>

<h3>3.5. File Handles</h3>

<p>
File handles should be named just as constants are.  Use meaningful
names that describe what exactly the handle represents, eschewing
meaningless names such as FILE.
</p>

<h2>4. Documentation Conventions</h2>

Use POD for all documentation.

<h3>4.1. Packages and Classes</h3>

<p>
A package should contain a preamble to all of the code that explains
the logical grouping of various functionalities.  A class should
contain as much, as well as have an explanation for how it interacts with
the object system as a whole.
</p>

<h3>4.2 Package Globals</h3>

<p>
An explanation of the roles and assumptions regarding package globals
should accompany their declarations.  A simple one liner may suffice
in some instances, but in others, a detailed description of its role
and mutation during the course of execution should be provided.
</p>

<h3>4.2. Functions and Methods</h3>

<p>
All functions should have a blurb preceding their bodies that explain
each of the following: input, output and effect.  The "input" section
should explain all of the different ways that arguments may be passed
into the function.  The "output" section should explain the form and
meaning of the return value of the function.  The "effect" section
should explain how arguments are mutated, how the return value is
formed, and how state information for any related processes is modified.
In the case of methods, an explanation should be given for how the
call affects the internal state of the object.
</p>

<p>
Arguments to a function should be extracted from the call stack in
such a way that it is apparent what their roles are in the course of
function execution.  In the case of method calls, the standard is to
shift the first element of @_ into the $self variable.  One may
typically deal with other arguments in one of two ways: shift them
into aptly named 'my' variables, or move the whole remainder of @_
into a hash for the purpose of having named parameters.  If done
properly, this practice leads to self-documenting code.
</p>

<p>
Inline code comments should appear wherever it is not readily apparent
what a piece of code is doing.  Meaty blocks of code should be explained much the
same way that a function is explained.  Of course, if the explanation
is really quite long, considering splicing the block out into another
function altogether.  Use "end of line" comments where they will fit,
or put comments of greater length on preceding lines.
</p>


<h2>5. Programming Conventions</h2>

<h3>Packages and Classes</h3>

<p>
Always, <i>always</i>, <b><i>always</i></b> use the 'strict' pragma.
For utility packages, use the Exporter module as a base to pollute the
namespaces of others. Use the 'base' pragma for inheritance.  Include
a $VERSION variable that CVS can update with each submission, and
write a 'version' subroutine that is a wrapper around this value.
</p>

<h3>Inheritance</h3>

<p>
Code reuse is your friend.  Keep classes and methods as small as
conceivable, making their puproses as singular as possible, thus
encouraging building things from parts.  Opt for composition whenever
it suits your purposes.  Use inheritance when it makes sense.
Multiple inheritance is considered scary; use it only as a last
resort.  Frivolous use of multiple inheritance will make you hate your
life.  If you do find yourself painted into a corner and opt for
multiple inheritance, make certain that the methods you think are
being called by the resulting objects are in fact the ones that are
<i>really</i> being called.
</p>

<h3>Constants</h3>

Try to split off configuration information into (perhaps XML
structured) configuration files instead of littering code with this
noise.  If constants must be embedded in the code, do so as much as
possible in a centralized location so as to reduce clutter.

<h3>Instance Data</h3>

<p>
Database based SQLRow objects have their fields configured by passing
in an array ref of fields as a named parameter _fields to the base
constructor.  Additional private data should be placed in the object
hash with a descriptive key value, beginning with '_' if it is
intended to be private.
</p>

<p>
Accessor functions should be written for data, with both get_foo and
set_foo forms, with is additonal possibility of is_foo.  Sanity checks
should be performed on arguments passed into setter methods.  Prefix a
'_' to the accessor methods for private data (and for that matter, to
all private functions).
</p>

<h3>Object Constructors</h3>

<p>
Object constructors are a little special as far as methods go.  The
first argument to a class' constructor can be either an object of
that type, or it can be the class' name.  As such, something close to
the following idiom should be employed for the constructor...
</p>

<pre>
sub new {
    my $invocant = shift();
    my $class = ref($invocant) || $invocant;
    my $self = {};
    bless($self, $class);
    ...
    return $self;
}
</pre>

<p>
In the case of a derived class where one wants to invoke the base constructor...
</p>

<pre>
sub new {
    my $invocant = shift();
    my $class = ref($invocant) || $invocant;
    my $self = $class->SUPER::new(... appropriate args ...);
    ...
    return $self;
}
</pre>

<h3>Function and Method Guard Clauses</h3>

In addition to documenting how a function or method should be called,
guard clauses should be employed to verify the integrity of the
arguments being provided.

<pre>
package Foo;

# INPUT:  an object of type Bar, and an integer to associate with it
# OUTPUT: the meaning of life
# EFFECT: gives a Foo a Bar, and maps an integer to it
sub set_bar {
    my Foo $self = shift();
    my $bar = shift();
    my $int = shift();

    # guard clauses
    croak "object method set_bar called without object reference" unless $self->isa('Foo');
    croak "expected an object of type Bar as first argument to method set_bar" unless $bar->isa('Bar');
    croak "expected an integer as second argument to method set_bar" unless $int =~ /^[0-9]+$/;

    ...
    # do some stuff
    ...

    my $ret = 1;
    map { $ret *= $_ } (2, 3, 7);
    return $ret;
}
</pre>

<h3>Exception Handling</h3>

In every function or method, verify the inputs, the output, as well as the results of intermediary
steps.  Throw apoplectic fits as appropriate, providing as much useful
information as conceivably possible.

<h4>die</h4>

<p>
Use die when there is an internal error, such as database connectivity
problems, resource failures, etc, as well as for programmatic errors.
</p>

<h4>croak</h4>

<p>
Use croak to generate error messages that are from the perspective of
the caller.  This is appropriate for invalid arguments to a function.
</p>

<h4>Exception Propagation</h4>

<p>Propagate exceptions with the following idiom...</p>

<pre>
    die "$@\t...looks like we dropped the ball here! " if $@;
</pre>

<p>Include any and all useful state information, but be wary of
over-cluttering the error message as it decreases readability, and
consequently increases time spend debugging.</p>

<h3>Efficiency</h3>

In general, programmer time is more expensive than machine time.
Accordingly, do not unreasonably sacrifice readability and
maintainability for the sake of a few clock cycles.  That being said,
there are a few good practices that can improve run time without
making undue sacrifices in other areas...

<h4>Avoid Unnecessarily Invoking External Programs</h4>

Whenever possible, do as much of the work as possible internal to
Perl, as making calls to external programs is obscenely expensive.

<h4>Avoid Long Argument Lists</h4>

Passing large numbers of arguments to subroutines can prove to be
expensive at runtime.  Instead, opt for references to lists or hashes instead
where sensible.

<h4>Cache the Results of Expensive Computations</h4>

<p>
Whenever an object method is called that performs an expensive
calculation that is apt to get reused again later, save the result in
the thingy for later recall.  The following idiom achieves this end...
</p>

<pre>
sub expensive {
    my $self = shift();

    unless($self->{_expensive}) {
       $self->{_expensive} = tedious_computation();
    }

    return $self->{_expensive};
}
</pre>

<p>
Private cache variables should begin with an underscore to signify
this role.  Normal member data should be named just like variables.
</p>

<h4>Pre-compute Data For Repetitious Operations, But Do So Judiciously</h4>

<p>
A little preprocessing can reduce the complexity of various
operations.  For example, the following code tests what elements of @b
are also members of @a in O(a+b) time instead of O(a*b) time...
</p>

<pre>
@a = ( ... );
@b = ( ... );
...
@s = ();
%h = map { ($_, 1) } @a;

foreach (@b) {
    push(@s, $_) if $h{$_};
}
</pre>

<p>
Of course, there ain't no such thing as a free lunch; pre-computation
can be useful, but it comes at a price, thus one must make sure that
the benefits outweigh the costs.  For very small lists, pre-compuation
may in fact hurt performance, so use common sense and context as guides.
</p>

<h2>6. Murphy's Law</h2>

<p>If there is more than one way to feed data into a program, and one
of those ways is wrong, one or more of our users do it that way.
ALWAYS ALWAYS ALWAYS verify all input to scripts, content of files,
arguments to functions, etc.  It will take more time up front, but you
will save an enormous amount of debugging time.</p>

</body>
</html>