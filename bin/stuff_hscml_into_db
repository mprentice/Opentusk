#!/usr/bin/perl -w

use strict;

use FindBin;
use lib "$FindBin::Bin/../lib";
use TUSK::Core::ServerConfig;
use Getopt::Long;
use TUSK::UploadContent;
use HSDB4::SQLRow::Content;
use MySQL::Password;
use HSDB4::Constants;
HSDB4::Constants::set_user_pw (get_user_pw);

if (!defined($ENV{DATABASE_ADDRESS})){
	$ENV{DATABASE_ADDRESS} = TUSK::Core::ServerConfig::dbWriteHost;
}
die "Need to set ENV{DATABASE_ADDRESS}" if (!defined($ENV{DATABASE_ADDRESS}));

my $verbose=""; # set to 1 then info is printed to the screen
GetOptions ("verbose!" => \$verbose);

my $processed_dir = $TUSK::UploadContent::path{'doc-processed'};

opendir (DIR,$processed_dir) or &error("Cannot open $processed_dir: $!");
my @dir = readdir(DIR);
closedir (DIR);

foreach my $file (@dir){
	next unless ($file =~ /\.xml$/);
	next unless ($file =~ /^(\d+)\./);
	my $content_id = $1;

	print "Processing: $file\n" if ($verbose);
	my $content = HSDB4::SQLRow::Content->new()->lookup_key($content_id);
	if ($content->primary_key()){
		open (my $fh, "<", $processed_dir . '/' . $file) or die ("Could not open $file: $!");
		my $hscml_body;
		while (my $line = <$fh>){
			$hscml_body .= $line;
		}
		close($fh);

		## crazy replace to make sure that &'s are transformed to entities in the web-cite tag
		$hscml_body =~ s/(<web-cite[^>]+uri=")([^\"]+)(")/$1 . &fix_uri($2) . $3/ge;

                # added fix for line return that is added to emph tags (inline style)
                $hscml_body =~s/(<\/?emph>)\r?\n/$1/g;

		$content->field_value('hscml_body', $hscml_body);
		$content->save_version("hscml body updated from $0");
		unlink $processed_dir . '/' . $file or die ("Could not clean up $file: $!");
	}else{
		# error case
	}
}


## function to replace any &amp; or & with &amp; so XML parser is happy
sub fix_uri{
    my ($string) = @_;
    $string =~ s/\&amp;|\&/\&amp;/g;
    return $string;
}
